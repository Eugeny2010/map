<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script type="text/javascript" src="https://gc.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=38xasvR_eG79ZCjdsyrjZTV2IPpTPboyRnAeS9R6Om3Y5NoY4RQe9CAEwoAqIWESkCkGEGtBcmgt2RIxZ3uRcw" charset="UTF-8"></script><style>
    @font-face {
      font-family: 'Aldrich';
      src: url('Aldrich-Regular.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    html, body { 
      margin: 0; 
      padding: 0; 
      height: 100%; 
      font-family: 'Aldrich', sans-serif;
      background-color: #121212;
      overflow: hidden;
    }
    
    #map-container {
      position: relative;
      height: 100vh;
      width: 100vw;
    }
    
    #map { 
      height: 100%; 
      width: 100%;
      background-color: #121212;
    }
    
    #noise-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.37;
      z-index: 1000;
      background: url('effect.gif') repeat;
      image-rendering: pixelated;
      animation: noise-animation 0.5s infinite;
    }
    
    @keyframes noise-animation {
      0% { opacity: 0.37; }
      50% { opacity: 0.38; }
      100% { opacity: 0.37; }
    }
    
    #error {
     visibility: none;
    }
    
    .custom-marker {
      background-color: #333;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      border: 2px solid #555;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .custom-marker-inner {
      width: 10px;
      height: 10px;
      background-color: #888;
      border-radius: 50%;
    }
    
    .leaflet-popup-content {
      padding: 10px;
      min-width: 150px;
      font-size: 14px;
      max-height: 80vh;
      overflow-y: auto;
      font-family: 'Aldrich', sans-serif;
      background-color: #1e1e1e;
      color: #e0e0e0;
    }
    
    .leaflet-popup-content-wrapper {
      background-color: #1e1e1e;
      color: #e0e0e0;
      border: 1px solid #333;
      box-shadow: 0 0 15px rgba(0,0,0,0.8);
      border-radius: 8px;
    }
    
    .leaflet-popup-tip {
      background-color: #1e1e1e;
    }
    
    .flag-container {
      text-align: center;
      margin: 0 auto 8px auto;
      width: 100%;
    }
    
    .flag-img {
      max-width: 200px;
      max-height: 120px;
      width: auto;
      height: auto;
      border: 1px solid #444;
      border-radius: 4px;
      display: block;
      margin: 0 auto;
    }
    
    .no-flag {
      color: #888;
      font-style: italic;
      font-size: 12px;
      text-align: center;
      padding: 5px 0;
    }
    
    .properties-list {
      margin-top: 8px;
      line-height: 1.4;
    }
    
    .properties-list b {
      display: inline-block;
      min-width: 80px;
      font-weight: bold;
      color: #ccc;
    }
    
    .properties-list div {
      margin-bottom: 3px;
      color: #aaa;
    }
    
    .leaflet-control-attribution {
      background-color: rgba(0,0,0,0.7) !important;
      color: #aaa !important;
      border-radius: 5px !important;
    }
    
    .leaflet-bar {
      background-color: #1e1e1e !important;
      border-color: #333 !important;
      border-radius: 8px !important;
      overflow: hidden;
    }
    
    .leaflet-bar a {
      background-color: #1e1e1e !important;
      color: #aaa !important;
      border-bottom-color: #333 !important;
    }
    
    .leaflet-bar a:hover {
      background-color: #333 !important;
      color: #ddd !important;
    }
    
    #audio-player {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: rgba(20, 20, 20, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 25px;
      padding: 12px 20px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      gap: 15px;
      border: 1px solid #333;
      max-width: 90%;
      box-sizing: border-box;
      transition: all 0.3s ease;
      z-index: 1001;
    }
    
    #audio-player.minimized {
      padding: 8px 15px;
      border-radius: 20px;
    }
    
    .player-btn {
      background: rgba(60, 60, 60, 0.7);
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    #audio-player.minimized .player-btn {
      width: 35px;
      height: 35px;
    }
    
    .player-btn:hover {
      background: rgba(80, 80, 80, 0.9);
      transform: scale(1.05);
    }
    
    .player-btn svg {
      width: 18px;
      height: 18px;
      fill: #e0e0e0;
    }
    
    #play-pause-btn {
      background: rgba(80, 80, 80, 0.9);
    }
    
    #play-pause-btn:hover {
      background: rgba(100, 100, 100, 0.9);
    }
    
    .player-info {
      flex-grow: 1;
      min-width: 0;
      color: #e0e0e0;
      font-size: 14px;
    }
    
    #track-title {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-weight: bold;
      margin-bottom: 3px;
    }
    
    #track-time {
      font-size: 12px;
      color: #aaa;
      display: flex;
      justify-content: space-between;
    }
    
    #progress-container {
      height: 4px;
      background: rgba(60, 60, 60, 0.5);
      border-radius: 2px;
      margin-top: 5px;
      cursor: pointer;
    }
    
    #progress-bar {
      height: 100%;
      background: #888;
      border-radius: 2px;
      width: 0%;
      transition: width 0.1s linear;
    }
    
    #volume-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    #volume-btn {
      display: flex;
      align-items: center;
    }
    
    #volume-slider {
      width: 80px;
      height: 4px;
      background: rgba(60, 60, 60, 0.5);
      border-radius: 2px;
      appearance: none;
      outline: none;
      cursor: pointer;
    }
    
    #volume-slider::-webkit-slider-thumb {
      appearance: none;
      width: 12px;
      height: 12px;
      background: #e0e0e0;
      border-radius: 50%;
      cursor: pointer;
    }
    
    #minimize-btn {
      display: none;
    }
    
    @media (max-width: 768px) {
      #audio-player {
        width: calc(100% - 40px);
        max-width: none;
        bottom: 10px;
        padding: 10px 15px;
      }
      
      .player-btn {
        width: 36px;
        height: 36px;
      }
      
      #volume-slider {
        width: 60px;
      }
      
      #minimize-btn {
        display: flex;
      }
      
      .player-info {
        font-size: 13px;
      }
    }
    
    @media (max-width: 480px) {
      #audio-player {
        flex-wrap: wrap;
        padding: 10px;
        gap: 10px;
      }
      
      .player-controls {
        display: flex;
        width: 100%;
        justify-content: space-between;
        order: 2;
      }
      
      .player-info {
        order: 1;
        width: 100%;
        margin-bottom: 8px;
      }
      
      #volume-container {
        display: none;
      }
      
      #audio-player.expanded #volume-container {
        display: flex;
        order: 3;
        width: 100%;
        margin-top: 8px;
      }
      
      #audio-player.expanded #volume-slider {
        flex-grow: 1;
      }
    }
  </style>
</head>
<body>
  <div id="map-container">
    <div id="map"></div>
    <div id="noise-overlay"></div>
  </div>
  <div id="error"></div>
  
  <div id="audio-player" class="minimized">
    <button id="prev-btn" class="player-btn" title="Предыдущий трек">
      <svg viewBox="0 0 24 24">
        <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
      </svg>
    </button>
    <button id="play-pause-btn" class="player-btn" title="Воспроизвести/Пауза">
      <svg id="play-icon" viewBox="0 0 24 24">
        <path d="M8 5v14l11-7z"/>
      </svg>
      <svg id="pause-icon" viewBox="0 0 24 24" style="display: none;">
        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
      </svg>
    </button>
    <button id="next-btn" class="player-btn" title="Следующий трек">
      <svg viewBox="0 0 24 24">
        <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
      </svg>
    </button>
    
    <div class="player-info">
      <div id="track-title">Загрузка...</div>
      <div id="track-time">
        <span id="current-time">0:00</span>
        <span id="total-time">0:00</span>
      </div>
      <div id="progress-container">
        <div id="progress-bar"></div>
      </div>
    </div>
    
    <div id="volume-container">
      <button id="volume-btn" class="player-btn" title="Громкость">
        <svg id="volume-high" viewBox="0 0 24 24">
          <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        </svg>
        <svg id="volume-mute" viewBox="0 0 24 24" style="display: none;">
          <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
        </svg>
      </button>
      <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5">
    </div>
    
    <button id="minimize-btn" class="player-btn" title="Свернуть/Развернуть">
      <svg id="expand-icon" viewBox="0 0 24 24">
        <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
      </svg>
      <svg id="collapse-icon" viewBox="0 0 24 24" style="display: none;">
        <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
      </svg>
    </button>
  </div>

  <audio id="track1" src="TNO OST - Toolbox Theory.mp3" preload="auto"></audio>
  <audio id="track2" src="The New Order_ Last Days of Europe - Russian Fairytale.mp3" preload="auto"></audio>
  <audio id="track3" src="Half-Life 2_ Overcharged - Particle Ghost (Remix).mp3" preload="auto"></audio>
  <audio id="track4" src="TNO OST - Burgundian Lullaby.mp3" preload="auto"></audio>
  <audio id="track5" src="The New Order - TNO OST_ Between the Bombings.mp3" preload="auto"></audio>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Оптимизация: кеширование DOM элементов и объектов
    const DOM = {
      mapContainer: document.getElementById('map-container'),
      map: document.getElementById('map'),
      noiseOverlay: document.getElementById('noise-overlay'),
      error: document.getElementById('error'),
      audioPlayer: document.getElementById('audio-player'),
      playPauseBtn: document.getElementById('play-pause-btn'),
      prevBtn: document.getElementById('prev-btn'),
      nextBtn: document.getElementById('next-btn'),
      volumeBtn: document.getElementById('volume-btn'),
      volumeSlider: document.getElementById('volume-slider'),
      progressContainer: document.getElementById('progress-container'),
      progressBar: document.getElementById('progress-bar'),
      currentTimeEl: document.getElementById('current-time'),
      totalTimeEl: document.getElementById('total-time'),
      trackTitleEl: document.getElementById('track-title'),
      minimizeBtn: document.getElementById('minimize-btn'),
      playIcon: document.getElementById('play-icon'),
      pauseIcon: document.getElementById('pause-icon'),
      volumeHighIcon: document.getElementById('volume-high'),
      volumeMuteIcon: document.getElementById('volume-mute'),
      expandIcon: document.getElementById('expand-icon'),
      collapseIcon: document.getElementById('collapse-icon')
    };

    // Оптимизация: предварительное создание объектов
    const worldBounds = L.latLngBounds(
      L.latLng(-85, -180),
      L.latLng(85, 180)
    );

    // Создаем карту с ограничениями
    const map = L.map(DOM.map, {
      maxBounds: worldBounds,
      maxBoundsViscosity: 0.7,
      minZoom: 3,
      maxZoom: 18,
      worldCopyJump: false,
      zoomControl: false
    }).setView([30, 0], 3);

    // Добавляем тёмные тайлы
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
      noWrap: true,
      attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
      subdomains: 'abcd',
    }).addTo(map);

    // Добавляем кастомный zoom control
    L.control.zoom({
      position: 'topright'
    }).addTo(map);

    // Иконка для маркеров (кешированная)
    const whiteMachineIcon = L.divIcon({
      className: 'custom-marker',
      html: '<div class="custom-marker-inner"></div>',
      iconSize: [20, 20],
      iconAnchor: [10, 10]
    });

    // Оптимизированная функция для создания содержимого popup
    const createPopupContent = (function() {
      const propsToExclude = new Set(['stroke', 'stroke-width', 'stroke-opacity', 'fill', 'fill-opacity', 'flag']);
      
      return function(feature) {
        if (!feature.properties) return "Нет данных";
        
        let content = "<div style='max-width:250px'><div class='flag-container'>";
        
        if (feature.properties.flag) {
          content += `<img src="${feature.properties.flag}" class="flag-img" alt="Флаг" 
                   onerror="this.parentNode.innerHTML='<div class=\\'no-flag\\'>Флаг не загружен</div>'>`;
        }
        content += "</div>";
        
        const props = feature.properties;
        const propsToShow = Object.keys(props).filter(k => !propsToExclude.has(k));
        
        if (propsToShow.length > 0) {
          content += '<div class="properties-list">';
          for (const key of propsToShow) {
            content += `<div><b>${key}</b> ${props[key] || ''}</div>`;
          }
          content += '</div>';
        }
        
        return content + "</div>";
      };
    })();

    // Оптимизация: загрузка GeoJSON с обработкой ошибок
    (function() {
      const markersLayer = L.layerGroup().addTo(map);
      const startTime = performance.now();
      
      fetch('map (11).geojson')
        .then(response => {
          if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
          return response.json();
        })
        .then(data => {
          if (!data.features) throw new Error("GeoJSON has no features");
          
          const geoJsonLayer = L.geoJSON(data, {
            pointToLayer: (feature, latlng) => {
              const marker = L.marker(latlng, {
                icon: whiteMachineIcon,
                bubblingMouseEvents: false
              });
              marker.bindPopup(createPopupContent(feature), {
                maxWidth: 300,
                minWidth: 150,
                className: 'dark-popup'
              });
              markersLayer.addLayer(marker);
              return marker;
            },
            style: (feature) => {
              const props = feature.properties || {};
              return {
                stroke: true,
                color: props['stroke'] || '#555',
                weight: parseInt(props['stroke-width']) || 2,
                opacity: parseFloat(props['stroke-opacity']) || 0.8,
                fill: true,
                fillColor: props['fill'] || '#333',
                fillOpacity: parseFloat(props['fill-opacity']) || 0.5
              };
            },
            onEachFeature: (feature, layer) => {
              if (feature.geometry.type !== 'Point') {
                layer.bindPopup(createPopupContent(feature)), {
                  maxWidth: 300,
                  minWidth: 150,
                  className: 'dark-popup'
                };
              }
            }
          }).addTo(map);
          
          console.log(`GeoJSON loaded and processed in ${(performance.now() - startTime).toFixed(2)}ms`);
        })
        .catch(error => {
          console.error("Loading error:", error);
          DOM.error.innerHTML = 
            `<b>Ошибка загрузки данных</b><br>
            ${error.message}<br><br>
            Проверьте:<br>
            1. Наличие файла map (11).geojson<br>
            2. Формат GeoJSON<br>
            3. Кодировку UTF-8`;
        });
    })();

    // Оптимизированный аудиоплеер
    (function() {
      // Список треков
      const tracks = [
        { element: document.getElementById('track1'), title: "TNO OST - Toolbox Theory" },
        { element: document.getElementById('track2'), title: "The New Order: Russian Fairytale" },
        { element: document.getElementById('track3'), title: "Half-Life 2: Particle Ghost (Remix)" },
        { element: document.getElementById('track4'), title: "TNO OST - Burgundian Lullaby" },
        { element: document.getElementById('track5'), title: "TNO OST - Between the Bombings" }
      ];
      
      let currentTrackIndex = Math.floor(Math.random() * tracks.length);
      let isPlaying = false;
      let isDraggingProgress = false;
      let wasPlayingBeforeDrag = false;
      let progressUpdateRAF = null;
      let lastProgressUpdate = 0;
      
      // Оптимизация: кеширование функций
      const formatTime = (function() {
        const format = (n) => n < 10 ? `0${n}` : n;
        return function(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${format(secs)}`;
        };
      })();
      
      const updateTrackInfo = function() {
        const track = tracks[currentTrackIndex];
        DOM.trackTitleEl.textContent = track.title;
        DOM.totalTimeEl.textContent = formatTime(track.element.duration || 0);
      };
      
      const updateProgress = function(now) {
        if (isDraggingProgress) return;
        
        // Оптимизация: использование requestAnimationFrame с регулированием частоты обновления
        if (now - lastProgressUpdate < 200 && progressUpdateRAF) {
          progressUpdateRAF = requestAnimationFrame(updateProgress);
          return;
        }
        lastProgressUpdate = now;
        
        const track = tracks[currentTrackIndex].element;
        const progress = (track.currentTime / track.duration) * 100;
        DOM.progressBar.style.width = `${progress}%`;
        DOM.currentTimeEl.textContent = formatTime(track.currentTime);
        
        progressUpdateRAF = requestAnimationFrame(updateProgress);
      };
      
      const updatePlayPauseButton = function() {
        DOM.playIcon.style.display = isPlaying ? 'none' : 'block';
        DOM.pauseIcon.style.display = isPlaying ? 'block' : 'none';
      };
      
      const updateVolumeButton = function() {
        const volume = tracks[currentTrackIndex].element.volume;
        DOM.volumeHighIcon.style.display = volume === 0 ? 'none' : 'block';
        DOM.volumeMuteIcon.style.display = volume === 0 ? 'block' : 'none';
      };
      
      const playTrack = function() {
        // Остановка предыдущего обновления прогресса
        if (progressUpdateRAF) {
          cancelAnimationFrame(progressUpdateRAF);
          progressUpdateRAF = null;
        }
        
        // Останавливаем все треки
        for (let i = 0; i < tracks.length; i++) {
          tracks[i].element.pause();
          tracks[i].element.currentTime = 0;
        }
        
        // Воспроизводим текущий трек
        const track = tracks[currentTrackIndex].element;
        const playPromise = track.play();
        
        if (playPromise !== undefined) {
          playPromise
            .then(() => {
              isPlaying = true;
              updatePlayPauseButton();
              updateTrackInfo();
              updateVolumeButton();
              lastProgressUpdate = 0;
              progressUpdateRAF = requestAnimationFrame(updateProgress);
            })
            .catch(error => {
              console.error("Playback failed:", error);
              playNextTrack();
            });
        }
      };
      
      const playNextTrack = function() {
        currentTrackIndex = (currentTrackIndex + 1) % tracks.length;
        playTrack();
      };
      
      const playPrevTrack = function() {
        const track = tracks[currentTrackIndex].element;
        if (track.currentTime > 3) {
          track.currentTime = 0;
          if (progressUpdateRAF) {
            cancelAnimationFrame(progressUpdateRAF);
            progressUpdateRAF = requestAnimationFrame(updateProgress);
          }
        } else {
          currentTrackIndex = (currentTrackIndex - 1 + tracks.length) % tracks.length;
          playTrack();
        }
      };
      
      const togglePlayPause = function() {
        const track = tracks[currentTrackIndex].element;
        if (isPlaying) {
          track.pause();
          isPlaying = false;
          if (progressUpdateRAF) {
            cancelAnimationFrame(progressUpdateRAF);
            progressUpdateRAF = null;
          }
        } else {
          const playPromise = track.play();
          if (playPromise !== undefined) {
            playPromise
              .then(() => {
                isPlaying = true;
                progressUpdateRAF = requestAnimationFrame(updateProgress);
              })
              .catch(error => {
                console.error("Playback failed:", error);
              });
          }
        }
        updatePlayPauseButton();
      };
      
      const setVolume = function(volume) {
        volume = Math.max(0, Math.min(1, volume));
        for (let i = 0; i < tracks.length; i++) {
          tracks[i].element.volume = volume;
        }
        DOM.volumeSlider.value = volume;
        updateVolumeButton();
        localStorage.setItem('playerVolume', volume);
      };
      
      const seekTo = function(event) {
        if (!isDraggingProgress) return;
        
        const track = tracks[currentTrackIndex].element;
        const rect = DOM.progressContainer.getBoundingClientRect();
        const pos = (event.clientX - rect.left) / rect.width;
        track.currentTime = pos * track.duration;
        
        // Ручное обновление прогресса
        const progress = (track.currentTime / track.duration) * 100;
        DOM.progressBar.style.width = `${progress}%`;
        DOM.currentTimeEl.textContent = formatTime(track.currentTime);
      };
      
      // Оптимизация: единый обработчик событий для мыши
      const handleMouseEvent = function(e) {
        if (e.type === 'mousedown') {
          isDraggingProgress = true;
          wasPlayingBeforeDrag = isPlaying;
          if (isPlaying) {
            tracks[currentTrackIndex].element.pause();
            isPlaying = false;
            updatePlayPauseButton();
          }
          seekTo(e);
        } else if (e.type === 'mousemove' && isDraggingProgress) {
          seekTo(e);
        } else if (e.type === 'mouseup' && isDraggingProgress) {
          isDraggingProgress = false;
          if (wasPlayingBeforeDrag) {
            const playPromise = tracks[currentTrackIndex].element.play();
            if (playPromise !== undefined) {
              playPromise
                .then(() => {
                  isPlaying = true;
                  updatePlayPauseButton();
                })
                .catch(error => {
                  console.error("Playback failed:", error);
                });
            }
          }
        }
      };
      
      // Оптимизация: единый обработчик событий для touch
      const handleTouchEvent = function(e) {
        if (!e.touches || e.touches.length === 0) return;
        
        if (e.type === 'touchstart') {
          isDraggingProgress = true;
          wasPlayingBeforeDrag = isPlaying;
          if (isPlaying) {
            tracks[currentTrackIndex].element.pause();
            isPlaying = false;
            updatePlayPauseButton();
          }
          seekTo(e.touches[0]);
        } else if (e.type === 'touchmove' && isDraggingProgress) {
          seekTo(e.touches[0]);
        } else if (e.type === 'touchend' && isDraggingProgress) {
          isDraggingProgress = false;
          if (wasPlayingBeforeDrag) {
            const playPromise = tracks[currentTrackIndex].element.play();
            if (playPromise !== undefined) {
              playPromise
                .then(() => {
                  isPlaying = true;
                  updatePlayPauseButton();
                })
                .catch(error => {
                  console.error("Playback failed:", error);
                });
            }
          }
        }
      };
      
      // Настройка обработчиков событий
      DOM.playPauseBtn.addEventListener('click', togglePlayPause);
      DOM.prevBtn.addEventListener('click', playPrevTrack);
      DOM.nextBtn.addEventListener('click', playNextTrack);
      
      DOM.volumeBtn.addEventListener('click', () => {
        setVolume(tracks[currentTrackIndex].element.volume === 0 ? 0.5 : 0);
      });
      
      DOM.volumeSlider.addEventListener('input', (e) => {
        setVolume(parseFloat(e.target.value));
      });
      
      DOM.progressContainer.addEventListener('mousedown', handleMouseEvent);
      document.addEventListener('mousemove', handleMouseEvent);
      document.addEventListener('mouseup', handleMouseEvent);
      
      DOM.progressContainer.addEventListener('touchstart', handleTouchEvent);
      document.addEventListener('touchmove', handleTouchEvent);
      document.addEventListener('touchend', handleTouchEvent);
      
      DOM.minimizeBtn.addEventListener('click', () => {
        DOM.audioPlayer.classList.toggle('minimized');
        DOM.audioPlayer.classList.toggle('expanded');
        DOM.expandIcon.style.display = DOM.audioPlayer.classList.contains('minimized') ? 'block' : 'none';
        DOM.collapseIcon.style.display = DOM.audioPlayer.classList.contains('minimized') ? 'none' : 'block';
      });
      
      // Обработчики событий для треков
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i].element;
        track.addEventListener('ended', playNextTrack);
        track.addEventListener('timeupdate', () => {
          if (!isDraggingProgress && !progressUpdateRAF) {
            progressUpdateRAF = requestAnimationFrame(updateProgress);
          }
        });
        track.addEventListener('loadedmetadata', updateTrackInfo);
        track.addEventListener('error', (e) => {
          console.error(`Track ${i} error:`, e);
          playNextTrack();
        });
      }
      
      // Загрузка сохранённой громкости
      const savedVolume = localStorage.getItem('playerVolume');
      setVolume(savedVolume !== null ? parseFloat(savedVolume) : 0.5);
      
      // Автоматическое воспроизведение при взаимодействии
      const handleFirstInteraction = function() {
        if (!isPlaying) {
          playTrack();
        }
        document.removeEventListener('click', handleFirstInteraction);
        document.removeEventListener('keydown', handleFirstInteraction);
        document.removeEventListener('touchstart', handleFirstInteraction);
      };
      
      document.addEventListener('click', handleFirstInteraction);
      document.addEventListener('keydown', handleFirstInteraction);
      document.addEventListener('touchstart', handleFirstInteraction);
      
      // Инициализация информации о треке
      updateTrackInfo();
    })();
  </script>
</body>
</html>